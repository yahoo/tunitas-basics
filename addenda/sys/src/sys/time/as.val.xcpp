// This is C++ 23 -*- c++ -*- -std=c++23 in the stylings of the S.C.O.L.D. design method.
// For terms and provenance see the LICENSE file at the top of the repository.
#divert <hpp>
#import sys.time.point
#import sys.time.duration
#import sys.time.val
#import sys.time.spec
#import sys.time.t
#import sys.time.tm
namespace sys::time {
  template<typename RESULT> auto as(val) -> RESULT = delete;
  template<> inline auto as<point>(val) -> point; 
  template<> inline auto as<duration>(val) -> duration; // and use duration_cast<...>(...) to change precision
  template<> inline auto as<spec>(val) -> spec; 
  template<> inline auto as<val>(val) -> val; 
  template<> inline auto as<t>(val) -> t; 
  template<> inline auto as<tm>(val) -> tm;
}
#endiv
#divert <ipp>
#import sys.time.duration_cast
#import std.int64_t
template<> auto sys::time::as<sys::time::duration>(val v0) -> duration {
  // properly formed or improperly formed
  durations::seconds const v1_sec(v0.tv_sec);
  durations::microseconds const v1_usec(v0.tv_usec);
  durations::microseconds const v2_sec(duration_cast<durations::microseconds>(v1_sec));
  durations::microseconds const v2_usec(v1_usec);
  durations::microseconds const v3(v2_sec + v2_usec);
  auto const v4 = duration_cast<duration>(v3);
  return v4;
}

template<> auto sys::time::as<sys::time::point>(val v0) -> point {
  duration const v1{as<sys::time::duration>(v0)};
  point const v2(v1);
  return v2;
}

template<> auto sys::time::as<sys::time::spec>(val v0) -> spec {
  std::int64_t const micro_per_sec = std::micro::den;
  static_assert(1 < micro_per_sec, "micro/sec should be one million");
  static_assert(1 == std::micro::num, "micro should be fractional");
  if (v0.tv_usec < micro_per_sec) {
    // Properly formed
    std::int64_t const nano_per_micro = std::nano::den/std::micro::den;
    static_assert(1 < nano_per_micro, "nano/micro should be one thousand");
    static_assert(1 == std::nano::num, "nano should be fractional");
    static_assert(1 == std::micro::num, "micro should be fractional");
    spec const v1 = {
      v0.tv_sec,
      v0.tv_usec * nano_per_micro
    };
    return v1;
  } else {
    // Improperly formed - this handles excess & overflow in v0.tv_usec
    std::int64_t const nano_per_sec = std::nano::den;
    static_assert(1 < nano_per_sec, "nano/sec should be one billion");
    static_assert(1 == std::nano::num, "nano should be fractional");
    durations::seconds const v1_sec(v0.tv_sec);
    durations::microseconds const v1_usec(v0.tv_usec);
    durations::microseconds const v2_sec(duration_cast<durations::microseconds>(v1_sec));
    durations::microseconds const v2_usec(v1_usec);
    durations::microseconds const v3(v2_sec + v2_usec);
    durations::nanoseconds const v4(duration_cast<durations::nanoseconds>(v3));
    spec const v5 = {
      v4.count() / nano_per_sec,
      v4.count() % nano_per_sec,
    };
    return v5;
  }
}

template<> auto sys::time::as<sys::time::val>(val v0) -> val {
  return v0;
}

template<> auto sys::time::as<sys::time::t>(val v0) -> t {
  std::int64_t const micro_per_sec = std::micro::den;
  static_assert(1 < micro_per_sec, "micro/sec should be one million");
  static_assert(1 == std::micro::num, "micro should be fractional");
  if (v0.tv_usec < micro_per_sec) {
    // Properly formed
    t const v1(v0.tv_sec);
    return v1;
  } else {
    durations::seconds const v1_sec(v0.tv_sec);
    durations::microseconds const v1_usec(v0.tv_usec);
    durations::microseconds const v2_sec(duration_cast<durations::microseconds>(v1_sec));
    durations::microseconds const v2_usec(v1_usec);
    durations::microseconds const v3(v2_sec + v2_usec);
    durations::seconds const v4(duration_cast<durations::seconds>(v3));
    t const v5(v4.count());
    return v5;
  }
}

#import sys.time.as.t
#import sys.time.as.tm
template<> auto sys::time::as<sys::time::tm>(val v0) -> tm {
  t const v1 = as<t>(v0);
  tm const v2 = as<tm>(v1);
  return v2;
}
#endiv
